Enter the lower and upper bound 
2
1000
2 	3 	5 	7 	11 	13 	17 	19 	23 	29 	31 	37 	41 	43 	47 	53 	59 	61 	67 	71 	73 	79 	83 	89 	97 	101 	103 	107 	109 	113 	127 	131 	137 	139 	149 	151 	157 	163 	167 	173 	179 	181 	191 	193 	197 	199 	211 	223 	227 	229 	233 	239 	241 	251 	257 	263 	269 	271 	277 	281 	283 	293 	307 	311 	313 	317 	331 	337 	347 	349 	353 	359 	367 	373 	379 	383 	389 	397 	401 	409 	419 	421 	431 	433 	439 	443 	449 	457 	461 	463 	467 	479 	487 	491 	499 	503 	509 	521 	523 	541 	547 	557 	563 	569 	571 	577 	587 	593 	599 	601 	607 	613 	617 	619 	631 	641 	643 	647 	653 	659 	661 	673 	677 	683 	691 	701 	709 	719 	727 	733 	739 	743 	751 	757 	761 	769 	773 	787 	797 	809 	811 	821 	823 	827 	829 	839 	853 	857 	859 	863 	877 	881 	883 	887 	907 	911 	919 	929 	937 	941 	947 	953 	967 	971 	977 	983 	991 	997



So from this we get that .... the prime numbers are only the array ... we can make a super algorithm by taking all the array variables in the array as prime numbers and then checking through it without making the use of for loop as we did it before.... So this will take a hell of a lot less amount of time for example the number that is 997 will take only 160 variables to be checked where as n/2 logic takes atleast 1000/2 = 500 sets of variables to be checked ... so this will be a hell of a lot faster than that ... let's make this name as 


############################## Jimut's Prime algorithm ###########################################################################################



Ok if this shit not works then we can do another thing ... we just need to reduce the repeting terms so.. we can do a thing by doing it ... is whenever the array's k*3 occurs we gonna take it ... ike prime * 3 ... and so... it's will be awesome....
